{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/Javascript/2019-12-20-array-1/","result":{"data":{"markdownRemark":{"html":"<h1>1. 배열(array)이란?</h1>\n<p>배열은 연관된 데이터를 묶어 관리하는 자료형의 집합으로,<br>\n객체의 일종이지만 내부적으로 특별하게 취급되어 일반적인 객체들과는 다른 특징을 가지고 있다.\n<br></p>\n<pre><code class=\"language-javascript\">typeof [] // object\n</code></pre>\n<p>배열을 구성하는 각각의 값을 <strong>배열 요소(element)</strong>라고 하며, 객체와 배열의 가장 큰 차이점인 <strong>인덱스(index)</strong>는 배열의 각 요소 간의 순서를 나타낸다.</p>\n<br>\n<h2>자바스크립트 배열의 특징</h2>\n<ol>\n<li>타입이 고정적이지 않아 같은 배열에 있는 배열 요소끼리 타입이 다를 수 있다.</li>\n<li>모든 배열은 Array 객체로 다뤄진다.</li>\n</ol>\n<p><br><br><br></p>\n<h1>2. 배열의 생성</h1>\n<h2>배열 리터럴</h2>\n<p>배열을 생성하는데 가장 쉬운 방법이다.</p>\n<pre><code class=\"language-javascript\">const empty = [] // 빈 배열\nconst number = [1, 2, 3] // 숫자 배열\nconst string = [\"one\", \"two\", \"three\"] // 문자 배열\nconst object = [{ prop: 1 }, { prop: 2 }, { prop: 3 }] // 객체 배열\nconst mix = [1, \"one\", { prop: 1 }, null] // 여러가지 배열\n</code></pre>\n<br>\n<h2>Array 생성자</h2>\n<p>Array 생성자는 주어진 인수에 따라 두가지 서로 다른 방식으로 동작한다.</p>\n<ol>\n<li>숫자 자료형 하나가 인수로 주어질 때 해당 수 만큼 비어있는 배열 생성, 인수가 양의 정수가 아니라면 에러가 나타난다.</li>\n<li>숫자 자료형이 하나가 아닌 여러 인수, 숫자 자료형이 아닌 다른 타입의 인수가 주어진다면 그 인수들을 요소로 가지고 있는 배열을 생성한다.</li>\n</ol>\n<pre><code class=\"language-javascript\">new Array(1) // [empty]\nnew Array(100) // [empty x 100]\n\nnew Array(1, 2, 3) // [1, 2, 3]\nnew Array(\"one\") // ['one']\n</code></pre>\n<br>\n<h2>Array.of</h2>\n<p>ES6에 추가된 메소드로 인수가 주어지면 그 인수들로 요소를 갖는 배열을 생성한다.<br>\n따라서, 비어있는 배열을 생성할 때만 Array 생성자를 사용하고 나머지는 Array.of 방식을 사용하는게 좋다.</p>\n<pre><code class=\"language-javascript\">// 기존\nnew Array(1, 2, 3) // [1, 2, 3]\n\n//ES6\nArray.of(1, 2, 3) // [1, 2, 3]\nArray.of(1) // [1]\n\n//생성자는 이 때만 사용\nnew Array(100) // [empty x 100]\n</code></pre>\n<p><br><br><br></p>\n<h1>3. 배열 요소 읽기</h1>\n<p>배열 요소의 각 순서는 <strong>인덱스</strong>를 통해 읽을 수 있다.<br>\n배열을 생성하면, 배열 안에 들어있는 각 요소는 순서대로 0부터 시작하는 인덱스를 갖게되는데<br>\n주의 할 점은 <strong>인덱스의 첫 번째 요소의 인덱스는 1로 시작하는게 아닌 0이라는 점</strong>이다.</p>\n<pre><code class=\"language-javascript\">const arr = [\"one\", \"two\", \"three\"]\narr[0] // 'one'\narr[1] // 'two'\narr[2] // 'three'\narr[3] // undefined\n</code></pre>\n<p><br><br><br></p>\n<h1>3. 배열 추가/제거 및 수정</h1>\n<h2>배열 요소 수정</h2>\n<p>대괄호 표기법과 <code>fill</code>메소드 사용하기</p>\n<pre><code class=\"language-javascript\">const number = [0, 1, 2, 3]\n\n//대괄호 표기법\narr[1] = 4\nconsole.log(arr) //[0, 4, 2, 3]\n\n//fill - 전체 채우기\narr.fill(0) // [0, 0, 0, 0]\n\n//fill - 2와 3사이를 4로 채우기\narr.fill(4, 2, 3) // [0, 1, 4]\n</code></pre>\n<br>\n<h2>배열 요소 추가</h2>\n<p>시작 부분 추가 <code>unshift</code>메소드와 끝 부분 추가 <code>push</code> 메소드 사용하기</p>\n<pre><code class=\"language-javascript\">const arr = []\n// unshift - 시작 부분 배열 요소 추가\narr.unshift(0) // [0]\narr.unshift(1, 2) // [1, 2, 0]\n\n// push - 끝 부분 배열 요소 추가\narr.push(0) // [0]\narr.push(1, 2) // [0, 1, 2]\n</code></pre>\n<br>\n<h2>배열 요소 제거</h2>\n<p>시작 부분 제거 <code>shift</code>메소드와 끝 부분 제거 <code>pop</code> 메소드 사용하기</p>\n<pre><code class=\"language-javascript\">const arr = [0, 1, 2]\n// shift - 시작 부분 배열 요소 제거\narr.shift() // [1,2]\narr.shift() // [2]\narr.shift() // []\n\n// pop - 끝 부분 배열 요소 제거\narr.pop() // [0, 1]\narr.pop() // [0]\narr.pop() // []\n</code></pre>\n<br>\n<h2>배열 요소 중간 삽입</h2>\n<p><code>splice</code>메소드를 사용하면 배열의 일부분을 통째로 변경 가능하다.</p>\n<pre><code class=\"language-javascript\">const arr = [0, 1, 2, 3, 4, 5]\n// index '2'인 요소 (세번째 요소) 부터 '3'개 바꿔치기\n\n// 제거된 요소 만큼 요소 개수 추가\narr.splice(2, 3, \"two\", \"three\", \"four\") // [2, 3, 4]\nconsole.log(arr) // [0, 1, 'two', 'three', 'four', 5]\n\n// 3개 제거 한 자리에 하나의 요소 추가\narr.splice(2, 3, \"two\") // [2, 3, 4]\nconsole.log(arr) // [0, 1, 'two', 5]\n\n// 인수 생략 시\narr.splice(2, 3) // [2, 3]\nconsole.log(arr) // [0, 1, 5]\n</code></pre>\n<br>\n<h2>배열 요소 뒤집기</h2>\n<p><code>reverse</code>메소드를 사용하면 배열을 거꾸로 뒤집을 수 있다.</p>\n<pre><code class=\"language-javascript\">const arr = [0, 1, 2, 3]\n\narr.reverse()\nconsole.log(arr) // [3, 2, 1, 0]\n</code></pre>\n<br>\n<h2>배열 요소 정렬</h2>\n<p><code>sort</code>메소드를 사용하면 원하는 대로 배열 요소를 정렬할 수 있다.<br>\n인수에 비교 함수를 넣음에 따라 오름차순, 내림차순을 결정한다.<br>\n인수가 없어도 정렬이 되지만 먼저 요소를 문자열로 변환한 후 유니코드를 비교하는 방식이므로 원하는 결과가 안나올 수 있으니 꼭 비교함수를 넣어주자!</p>\n<pre><code class=\"language-javascript\">const arrNum = [3, 0, 4, 2, 5, 1]\nconst arrStr = [\"ccc\", \"bb\", \"a\", \"dddd\"]\n\n// 오름차순 (a, b) => a - b\narrNum.sort((a, b) => a - b) // [0, 1, 2, 3, 4, 5]\narrStr.sort((a, b) => a.length - b.length) // ['a', 'bb', 'ccc', 'dddd']\n\n// 내림차순 (a, b) => b - a\narrNum.sort((a, b) => b - a) // [5, 4, 3, 2, 1, 0]\narrStr.sort((a, b) => b.length - a.length) // ['dddd', 'ccc', 'bb', 'a']\n</code></pre>\n<br>\n<h2>배열의 길이</h2>\n<p>배열 요소의 개수는 배열의 길이라고도 불린다.<br>\n그러기 때문에 <code>length</code>속성을 사용하면 배열의 개수 즉, 배열의 길이를 알 수 있다.</p>\n<pre><code class=\"language-javascript\">const arr = []\nconsole.log(arr) // 0\n\nconst arr = [0, 1]\nconsole.log(arr) // 2\n</code></pre>\n<p><br><br><br></p>\n<h1>4. 배열 순회</h1>\n<p>배열의 모든 요소에 차례대로 접근하는 작업을 순회라고 한다.</p>\n<br>\n<h2><code>for</code>문</h2>\n<p>말 그래도 반복문 <code>for</code>문을 이용하여 루프를 도는것이다. 거의 쓰이지 않는다.</p>\n<pre><code class=\"language-javascript\">const arr = [0, 1, 2, 3]\n\nfor (let i = 0; i &#x3C; arr.length; i++) {\n    console.log(arr[i])\n}\n</code></pre>\n<br>\n<h2><code>forEach</code>메소드</h2>\n<p>배열의 각 요소에 대해 함수를 호출 할 수 있다.</p>\n<pre><code class=\"language-javascript\">const arr = [0, 1, 2, 3]\n\narr.forEach((item) => {\n    console.log(item)\n})\n</code></pre>\n<br>\n<h2><code>for...of</code>문</h2>\n<p>배열의 각 요소에 대해 함수를 호출 할 수 있다.</p>\n<pre><code class=\"language-javascript\">const arr = [0, 1, 2, 3]\n\nfor (let item of arr) {\n    console.log(item)\n}\n</code></pre>\n<br>\n<blockquote>\n<p>코드의 실행 속도가 중요하다면 -> <code>for</code>문<br>\n단순히 배열을 순회하기 목적이라면 -> <code>forEach</code>메소드<br>\n배열의 순회하면서 인덱스가 필요한 경우 -> <code>for...of</code>문</p>\n</blockquote>\n<p><br><br><br></p>\n<h1>5. 배열 메소드</h1>\n<p>배열을 보다 유용하게 활용하기 위해서 순회하는 것으로 작업 할 수 있지만,<br>\n보다 더 쉽게\n내장된 메소드를 사용하면 훨씬 수월하게 할 수 있다.<br>\n아래 메소드는 원본 배열에 아무런 영향을 미치지 않는다!</p>\n<br>\n<h2><strong><code>slice</code></strong></h2>\n<p>배열의 일부분을 선택하여 새로운 배열 반환</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.slice(start, end)\n</code></pre>\n<ul>\n<li>start : 배열의 start에 해당하는 index 요소부터</li>\n<li>end : 배열의 end에 해당하는 바로 전 요소까지</li>\n<li>인수 없이 호출하면 배열 전체 복사한다.</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [0, 1, 2, 3]\n\n// index '1'부터 index '3' 사이의 요소가지고 새로운 배열 생성\nconst newArr = arr.slice(1, 3) // [1, 2]\nnewArr[0] = 3 // [3, 2]\n\nconsole.log(arr) // [0, 1, 2, 3]\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>map</code></strong></h2>\n<p>배열을 반복하며 각 요소에 함수를 적용하면서 그 반환값으로 새로운 배열생성.<br>\n<code>foreach</code>문과 비슷해 보이지만, <strong>새로운 배열</strong>을 만든다는 것이 차이점</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.map(item => {reture item});\narray.map((item, index, array) => {reture item});\n</code></pre>\n<ul>\n<li>item : 배열의 요소 중, 현재 처리되고 있는 요소</li>\n<li>index : 현재 처리되어있는 요소의 배열 내 인덱스</li>\n<li>array : 메소드가 적용되는 기존 배열</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [0, 1, 2, 3]\n\nconst newArr = arr.map((item) => item + 1)\nconst newArr2 = arr.map((item, index, arr) => {\n    return item * index\n})\n\nconsole.log(newArr) // [1, 2, 3, 4]\nconsole.log(newArr2) // [0, 1, 4, 9]\nconsole.log(arr) // [0, 1, 2, 3]\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>concat</code></strong></h2>\n<p>여러 배열을 연결해서 새로운 배열 생성</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">const newArray = array1.concat(array2,...)\n</code></pre>\n<ul>\n<li>newArray : 새로운 배열 이름</li>\n<li>arr1 : 호출된 배열</li>\n<li>arr2 : 연결한 배열</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr1 = [0, 1]\nconst arr2 = [2, 3]\n\nconst newArray = arr1.concat(arr2, [4, 5])\nconsole.log(newArray) // [0, 1, 2, 3, 4, 5]\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>reduce</code></strong></h2>\n<p>모든 요소의 값을 종합해서 하나의 값으로 만드는 계산</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.reduce(callback, initialValue)\n</code></pre>\n<ul>\n<li>callback : 배열의 각 요소에 대해 실행할 함수, 네 가지 인수가 있다.\n_ accumulator : 콜백의 반환값을 누적한다. 콜백의 이전 반환값 또는 initialValue값\n_ item : 처리할 현재 요소\n_ index : 처리할 현재 요소의 인덱스\n_ array : reduce()를 호출한 현재 배열</li>\n<li>initialValue : callback의 첫 번재 인수에 제공하는 값, 인수가 없다면 배열의 첫 번째 요소 사용</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [1, 2, 3, 4]\n\narr.reduce((acc, item) => acc + item, 0) //10\n</code></pre>\n<ol>\n<li>acc에 초기값 0 대입, 배열의 첫 번째 요소 1 대입 -> 결과값 1 (누적값)</li>\n<li>누적값 1과, 배열의 두 번째 요소 2 대입 -> 결과값 3 (누적값)</li>\n<li>누적값 3과, 배열의 두 번째 요소 3 대입 -> 결과값 6 (누적값)</li>\n<li>누적값 6과, 배열의 두 번째 요소 4 대입 -> 결과값 10</li>\n</ol>\n<p><br><br></p>\n<h2><strong><code>filter</code></strong></h2>\n<p>배열에서 원하는 요소만 골라내어 새로운 배열 생성</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.filter(callback, thisArg)\n</code></pre>\n<ul>\n<li>callback : 배열의 각 요소에 대해 실행할 함수\n_ item : 처리할 현재 요소\n_ index : 처리할 현재 요소의 인덱스 * array : reduce()를 호출한 현재 배열</li>\n<li>thisArg : callback을 실행할 때 this로 사용하는 값</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [1, 2, 3, 4]\n\n//짝수만\narr.filter((item) => item % 2 === 0) // [2, 4]\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>join</code></strong></h2>\n<p>배열의 모든 요소들을 연결해 하나의 문자열로 생성</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.join(separator)\n</code></pre>\n<ul>\n<li>separator : 배열의 각 요소를 구분할 문자열</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [1, 2, 3, 4];\n\narr.join(+); // 1+2+3+4\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>indexOf</code></strong>, <strong><code>lastIndexOf</code></strong></h2>\n<p>특정 요소의 index 값 반환, 만약 일치하는 요소가 없다면 둘 다 <code>-1</code> 반환</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.indexOf(item, start)\narray.lastIndexOf(item, start)\n</code></pre>\n<ul>\n<li>item : 배열에서 찾을 요소</li>\n<li>start : 배열의 start에 해당하는 index 요소부터</li>\n<li>indexOf : 왼쪽에서 부터</li>\n<li>lastIndexOf : 오른쪽에서 부터</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [1, 2, 2, 4]\n\narr.indexOf(2) // 1\narr.lastIndexOf(2) // 2\narr.indexOf(2, 2) // 2\narr.lastIndexOf(2, 1) // 1\n\narr.indexOf(3) //-1\narr.lastIndexOf(3) //-1\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>find</code></strong>, <strong><code>findIndex</code></strong></h2>\n<p>특정 조건을 만족하는 요소 반환, 만약 일치하는 요소가 없다면 find는 <code>undefined</code>를, findIndex는 <code>-1</code> 반환</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.find(callback, thisArg)\narray.findIndex(callback, thisArg)\n</code></pre>\n<ul>\n<li>callback : 배열의 각 요소에 대해 실행할 함수\n_ item : 처리할 현재 요소\n_ index : 처리할 현재 요소의 인덱스 * array : reduce()를 호출한 현재 배열</li>\n<li>thisArg : callback을 실행할 때 this로 사용하는 값</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [\"banana\", \"strawberry\", \"melon\", \"apple\"]\n\narr.find((item) => item.length > 6) // strawberry\narr.findIndex((item) => item.length > 6) // 1\n\narr.find((item) => item.length > 8) // undefined\narr.findIndex((item) => item.length > 8) // -1\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>includes</code></strong></h2>\n<p>배열이 특정 요소를 포함하고 있는지 판별</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.includes(item, start)\n</code></pre>\n<ul>\n<li>item : 배열에서 찾을 요소</li>\n<li>start : 배열의 start에 해당하는 index 요소부터</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [\"apple\", \"strawberry\", \"melon\"]\n\narr.includes(\"apple\") // true\narr.includes(\"apple\", 1) // false\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>every</code></strong></h2>\n<p>모든 요소가 조건을 만족하는지 검사</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.every(callback, thisArg)\n</code></pre>\n<ul>\n<li>callback : 배열의 각 요소에 대해 실행할 함수,\n_ item : 처리할 현재 요소\n_ index : 처리할 현재 요소의 인덱스 * array : reduce()를 호출한 현재 배열</li>\n<li>start : callback을 실행할 때 this로 사용하는 값</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [\"apple\", \"strawberry\", \"melon\"]\n\narr.every((item) => item.length > 2) // true\narr.every((item) => item.length > 5) // false\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>some</code></strong></h2>\n<p>조건을 만족하는 요소가 하나라도 있는지 검사</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">array.some(callback, thisArg)\n</code></pre>\n<ul>\n<li>callback : 배열의 각 요소에 대해 실행할 함수,\n_ item : 처리할 현재 요소\n_ index : 처리할 현재 요소의 인덱스 * array : reduce()를 호출한 현재 배열</li>\n<li>start : callback을 실행할 때 this로 사용하는 값</li>\n</ul>\n<pre><code class=\"language-javascript\">const arr = [\"apple\", \"strawberry\", \"melon\"]\n\narr.some((item) => item.length > 2) // true\narr.some((item) => item.length > 10) // false\n</code></pre>\n<p><br><br></p>\n<h2><strong><code>Array.isArray</code></strong></h2>\n<p>어떤 값이 배열인지 아닌지 판별</p>\n<h4>문법</h4>\n<pre><code class=\"language-javascript\">Array.isArray(obj)\n</code></pre>\n<pre><code class=\"language-javascript\">let arr = [\"one\", \"two\", \"three\"]\n\nArray.isArray(arr) // true\nArray.isArray([\"one\", \"two\", \"three\"]) // true\nArray.isArray(\"hello\") // false\n</code></pre>\n<p><br><br><br><br><br></p>\n<blockquote>\n<p><subtitle> refernece</p>\n</blockquote>\n<ul>\n<li><a href=\"https://helloworldjavascript.net/pages/190-array.html\">https://helloworldjavascript.net/pages/190-array.html</a></li>\n<li><a href=\"http://tcpschool.com/javascript/js_array_basic\">http://tcpschool.com/javascript/js_array_basic</a></li>\n</ul>","frontmatter":{"title":"자바스크립트 - 배열(Array) 이해하기"},"excerpt":"1. 배열(array)이란? 배열은 연관된 데이터를 묶어 관리하는 자료형의 집합으로, 객체의 일종이지만 내부적으로 특별하게 취급되어 일반적인 객체들과는 다른 특징을 가지고 있다.\n 배열을 구성하는 각각의 값을 배열 요소(element…"}},"pageContext":{"slug":"/posts/Javascript/2019-12-20-array-1/"}}}