{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/Javascript/2019-12-11-es6-2/","result":{"data":{"markdownRemark":{"html":"<h1>1. 화살표 함수(Arrow Function)?</h1>\n<p>ES6에서 새로 도입된 기능으로 기존 function 함수보다 더 짧은 함수 구문을 작성할 수 있다.<br>\n기존 function 함수에서 function 키워드 대신 화살표( <strong>=></strong> )를 사용하여 화살표 함수라 불린다.</p>\n<p><br><br><br></p>\n<h1>2. 화살표 함수 선언</h1>\n<pre><code class=\"language-javascript\">// 기존\nvar sum = function (a, b) {\n    return a + b\n}\n\n// ES6\nconst sum = (a, b) => {\n    return a + b\n}\n\n//매개변수가 없는 경우\nconst sum = () => {\n    return a + b\n}\nconst sum = () => {\n    return { a: 1 }\n} //객체변환할 때 중괄호 사용\nconst sum = () => ({ a: 1 }) //객체를 바로 return 바로 할 땐 소괄호 사용\n\n//매개변수가 1개인 경우\nconst sum = (a) => {\n    return a + 1\n} //매개변수 1개인 경우 소괄호 생략 가능\nconst sum = (a) => a + 1 //함수가 한 줄로 표현 가능하면 중괄호 생략 가능, 자동 return\n\n//매개변수가 2개이상인 경우\nconst sum = (a, b) => a + b\n</code></pre>\n<p><br><br><br></p>\n<h1>3. 화살표 함수 호출</h1>\n<pre><code class=\"language-javascript\">// 기존\nvar sum = function (a, b) {\n    return a + b\n}\nconsole.log(sum(1, 2)) //3\n\nvar sumArr = [1, 2, 3]\nvar sum = sumArr.map(function (a, b) {\n    return a + b\n})\nconsole.log(sum) //[1, 3, 5]\n\n// ES6\nconst sum = (a, b) => a + b\nconsole.log(sum(1, 2)) //3\n\nconst sumArr = [1, 2, 3]\nvar sum = sumArr.map((a, b) => a + b)\nconsole.log(sum) //[1, 3, 5]\n</code></pre>\n<p><br><br><br></p>\n<h1>4. this</h1>\n<p>화살표 함수의 this는 일반 함수의 this와 많이 다르다.<br></p>\n<h2>일반 함수 - this</h2>\n<p>일반함수의 this 경우는 함수를 호출 할때, 함수가 어떻게 호출되었는지에 따라 값이 바뀐다.</p>\n<pre><code class=\"language-javascript\">const calc = {\n    num1: 1,\n    sum: function () {\n        console.log(this.num1) // 1\n        setTimeout(function () {\n            console.log(this) // window\n            console.log(this.num1) // undefined\n        }, 1000)\n    },\n}\n\ncalc.sum()\n</code></pre>\n<p>위 같은 경우 seTimeout 함수 같은 경우는 생성자 함수, 객체의 메소드가 아닌 <strong>함수의 내부함수, 콜백함수</strong>이기 때문에 전역 객체인 window를 가리키는 거다.</p>\n<p>이런 경우 함수 내부 this가 호출한 객체를 가리키게 하려면 2가지 방법이 있다.\n<br></p>\n<pre><code class=\"language-javascript\">// Solution 1 : that\nconst calc = {\n    num1: 1,\n    sum: function () {\n        const that = this\n        console.log(this.num1) // 1\n        setTimeout(function () {\n            console.log(that) // {num1: 1, sum: ƒ}\n            console.log(that.num1) // 1\n        }, 1000)\n    },\n}\n\n// Solution 2 : bind\nconst calc = {\n    num1: 1,\n    sum: function () {\n        console.log(this.num1) // 1\n        setTimeout(\n            function () {\n                console.log(this) // {num1: 1, sum: ƒ}\n                console.log(this.num1) // 1\n            }.bind(this),\n            1000\n        )\n    },\n}\n</code></pre>\n<p><br><br></p>\n<h2>화살표 함수 - this</h2>\n<p>동적으로 결정되는 일반 함수와 달리 화살표 함수의 this는 정적으로 된다.<br>\n화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다.<br>\n** 화살표 함수는 call, apply, bind 메소드를 사용해도 this를 변경할 수 없다.</p>\n<pre><code class=\"language-javascript\">const calc = {\n    num1: 1,\n    sum: function () {\n        console.log(this.num1) // 1\n        setTimeout(() => {\n            console.log(this) // {num1: \"1\", sum : f}\n            console.log(this.num1) // 1\n        }, 1000)\n    },\n}\n</code></pre>\n<p><br><br><br></p>\n<h1>5. 화살표 함수를 사용하면 안되는 경우</h1>\n<h2>객체의 메소드를 정의하는 경우</h2>\n<p>메소드를 소유한 객체가 아닌 전역객체 window를 가리키게 된다.</p>\n<pre><code class=\"language-javascript\">// Bad\nconst calc = {\n    num1: 1,\n    sum: () => {\n        console.log(this.num1)\n    },\n}\n\ncalc.sum() // undefined\n\n// Good\nconst calc = {\n    num1: 1,\n    sum() {\n        console.log(this.num1)\n    },\n}\n\ncalc.sum() // 1\n</code></pre>\n<br>\n<h2>생성자 함수로 사용할 경우</h2>\n<p>생성자 함수는 prototype 프로퍼티를 가지지만, 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다.</p>\n<pre><code class=\"language-javascript\">const fruit = () => {}\n\nconsole.log(fruit.hasOwnProperty(\"prototype\"))\n\nconst fruit = new fruit()\n</code></pre>\n<br>\n<h2>addEventListener 함수의 콜백함수로 정의할 경우</h2>\n<p>화살표 함수를 사용할 경우 전역 객체 window를 가리킨다.</p>\n<pre><code class=\"language-javascript\">// Bad\nvar btn = document.getElementById(\"fruit\")\nbtn.addEventListener(\"click\", () => {\n    console.log(this === window) //true\n    this.innerHTML = \"Click!!\"\n})\n\n// Good\nvar btn = document.getElementById(\"fruit\")\nbtn.addEventListener(\"click\", function () {\n    console.log(this === button) //true\n    this.innerHTML = \"Click!!\"\n})\n</code></pre>\n<br>\n<p><br><br><br><br><br></p>\n<blockquote>\n<p><subtitle> refernece</p>\n</blockquote>\n<ul>\n<li><a href=\"https://webapplog.com/es6/\">https://webapplog.com/es6/</a></li>\n<li><a href=\"https://yunyoung1819.tistory.com/123\">https://yunyoung1819.tistory.com/123</a></li>\n<li><a href=\"https://poiemaweb.com/\">https://poiemaweb.com/</a></li>\n<li><a href=\"https://developer.mozilla.org/\">https://developer.mozilla.org/</a></li>\n</ul>","frontmatter":{"title":"자바스크립트 - ES6 문법 (화살표 함수)"},"excerpt":"1. 화살표 함수(Arrow Function)? ES6에서 새로 도입된 기능으로 기존 function 함수보다 더 짧은 함수 구문을 작성할 수 있다. 기존 function 함수에서 function…"}},"pageContext":{"slug":"/posts/Javascript/2019-12-11-es6-2/"}}}