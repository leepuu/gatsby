{"componentChunkName":"component---src-templates-post-view-js","path":"/posts/Blog/2019-12-11-es6-1/","result":{"data":{"markdownRemark":{"html":"<blockquote>\n<p><subtitle> ECMAScript란? </subtitle><br>\n자바스크립트 표준 문법으로, 넷스케이프라는 회사에서 자바스크립트를 표준화하기 위해 만들어 낸 기술 규격이다.</p>\n</blockquote>\n<p><br><br><br></p>\n<h1>1. 기본 매개 변수</h1>\n<ul>\n<li>매개변수에 기본값을 지정해줄 수 있다.</li>\n</ul>\n<pre><code class=\"language-javascript\">// 기존\nvar sum = function (x, y) {\n    var x = 10\n    var y = 20\n\n    return x + y\n}\n\n// ES6\nvar sum = function (x = 10, y = 20) {\n    return x + y\n}\n</code></pre>\n<p><br><br><br></p>\n<h1>2. 템플릿 문자열</h1>\n<ul>\n<li>템플릿 리터럴을 제공하여 문자열 안에 <code>${~~}</code>라는 새로운 구문을 사용하여 추가 할 수 있다.</li>\n<li>여러 줄 문자열도 <code class=\"language-plaintext highlighter-rouge\">`</code> 문자를 사용하여 간편하게 삽입 가능하다.</li>\n</ul>\n<pre><code class=\"language-javascript\">// 기존\nvar info = \"My name is\" + name + \". I am\" + age + \"years old.\"\n\nvar info =\n    \"Lorem Ipsum is simply dummy text of the printing and typesetting industry. \\n\\t\" +\n    \"Lorem Ipsum has been the industrys standard dummy text ever since the 1500s,\\n\\t\" +\n    \"when an unknown printer took a galley of type and scrambled it to make a type specimen book. \\n\\t\" +\n    \"It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. \\n\\t\" +\n    \"It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages,\\n\\t\" +\n    \"and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\"\n\n// ES6\nvar info = `My name is ${name}. I am ${age} years old.`\n\nvar info = `Lorem Ipsum is simply dummy text of the printing and typesetting industry.\n      Lorem Ipsum has been the industrys standard dummy text ever since the 1500s,\n      when an unknown printer took a galley of type and scrambled it to make a type specimen book. \n      It has survived not only five centuries, but also the leap into electronic typesetting,   remaining essentially unchanged. \n      It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, \n      and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.`\n</code></pre>\n<p><br><br><br></p>\n<h1>3. 비구조화 할당</h1>\n<ul>\n<li>Object나 Array로 구조화된 변수를 다시 분해 시켜 할당하는 문법</li>\n</ul>\n<br>\n<h2>1. 배열</h2>\n<p>변수를 대괄호( <strong>[]</strong> )를 사용하여 받을 수 있다.</p>\n<pre><code class=\"language-javascript\">// 기존\nvar num = [1, 2, 3]\nvar one = num[0] // 1\nvar two = num[1] // 2\nvar three = num[2] // 3\n\n// ES6\nconst num = [1, 2, 3]\nconst [one, two, three] = num // one -> 1, teo -> 2, three -> 3\nconst [one, two, three] = [1, 2, 3]\nconst [one, two, three, four = 4] = [1, 2, 3] // 기본값 지정 가능\nconst [one, ...rest] = num //함수 마지막  파라미터 앞에 ... 를 붙이면 나머지 인수를 나타냄\n\nconsole.log(one) // 1\nconsole.log(four) // 2\nconsole.log(rest) //[2, 3]\n</code></pre>\n<p><br><br></p>\n<h2>2. 객체</h2>\n<p>배열과 다른 점은 객체의 프로퍼티명으로 받을 수 있다. 중괄호( <strong>{}</strong> )를 사용하면 된다.</p>\n<pre><code class=\"language-javascript\">// 기존\nvar num = {\n    one: 1,\n    two: 2,\n    three: 3,\n}\n\nvar one = num.one\nvar two = num.two\nvar three = num.three\nconsole.log(one, two, three) //1 2 3\n\n// ES6\nconst { one, two, three } = {\n    //기본\n    one: 1,\n    two: 2,\n    three: 3,\n}\n\nconst { one, ...rest } = {\n    // 나머지\n    one: 1,\n    two: 2,\n    three: 3,\n}\n\nconst { one, two, three, four = 4 } = {\n    // 기본값\n    one: 1,\n    two: 2,\n    three: 3,\n}\n\nconsole.log(one, two, three) //1 2 3\nconsole.log(rest) //{two: 2, three: 3}\nconsole.log(four) //4\n\n//문법\nconst { prop1, prop2 } = { prop1: \"a\", prop2: \"b\" }\nconsole.log({ prop1, prop2 }) // {prop1 : 'a', prop2 : 'b'}\n</code></pre>\n<p><br><br></p>\n<h1>4. 객체 리터럴 기능 확장</h1>\n<p>객체 리터럴의 사용이 훨씬 간편해졌다.</p>\n<h4>1. 프로퍼티 축약 표현</h4>\n<pre><code class=\"language-javascript\">// 기존\nvar one = 1,\n    two = 2\nvar num = { one: one, two: two }\nconsole.log(num) // {one: 1, two: 2}\n\n// ES6\nlet one = 1,\n    two = 2\nconst num = { one, two }\nconsole.log(num) // {one: 1, two: 2}\n</code></pre>\n<br>\n<h4>2. 프로퍼티 키 동적 생성</h4>\n<pre><code class=\"language-javascript\">// 기존\nvar one = 1\nvar i = 0\nvar num = {}\n\nnum[one + \"-\" + ++i] = i\nnum[one + \"-\" + ++i] = i\nnum[one + \"-\" + ++i] = i // 객체 리터럴 외부에서 사용\n\nconsole.log(num) // {1-1: 1, 1-2: 2, 1-3: 3}\n\n// ES6\nconst one = 1\nlet i = 0\n\nconst num = {\n    // 객체 리터럴 내부에서 사용\n    [`${one}-${++i}`]: i,\n    [`${one}-${++i}`]: i,\n    [`${one}-${++i}`]: i,\n}\n\nconsole.log(num) // {1-1: 1, 1-2: 2, 1-3: 3}\n</code></pre>\n<br>\n<h4>3. 메소드 축약 표현</h4>\n<pre><code class=\"language-javascript\">// 기존\nvar num = {\n    one: 1,\n    sum: function () {\n        console.log(this.one + 1) // 2\n    },\n}\n\nnum.sum() // 2\n\n// ES6\nconst num = {\n    one: 1,\n    sum() {\n        console.log(this.one + 1)\n    },\n}\n\nnum.sum() // 2\n</code></pre>\n<br>\n<h4>4. <code>__proto__</code> 프로퍼티에 의한 상속</h4>\n<pre><code class=\"language-javascript\">// 기존\nvar one = {\n    num: 1,\n    sum: function () {\n        console.log(this.num + 1)\n    },\n}\n\nvar two = Object.create(one) // 프로토타입 패턴 상속\ntwo.num = 2\n\none.sum() // 2\ntwo.sum() // 3\n\n// ES6\nconst one = {\n    num: 1,\n    sum() {\n        console.log(this.num + 1)\n    },\n}\n\nconst two = {\n    __proto__: one, // two 객체의 프로토타입 객체에 one 객체를 바인딩하여 상속을 구현\n    num: 2,\n}\n\none.sum() // 2\ntwo.sum() // 3\n</code></pre>\n<p><br><br><br></p>\n<h1>5. 프로미스</h1>\n<ul>\n<li>자바스크립트는 거의 대부분 작업들이 *비동기처리를 위해 콜백함수를 사용했다.<br>\n하지만 콜백 사용되는 경우가 많아지면서 비동기 처리를 중첩시키기 때문에 <strong>에러, 예외 처리가 어렵다</strong>는 것도 <strong>중첩으로 인한 복잡도가 증가</strong>하는 것이다.<br>\n이를 해결하기위해 ES6에선 프로미스(Promise)를 도입하였다.</li>\n</ul>\n<p>비동기란? 특정코드의 실행이 완료될 때까지 기다리지 않고 다음코드를 먼저 수행하는 것</p>\n<pre><code class=\"language-javascript\">//콜백 지옥\nfun1(function () {\n    fun2(function () {\n        fun3(function () {\n            fun4(function () {\n                fun5(function () {\n                    console.log(\"콜백 헬~!\")\n                })\n            })\n        })\n    })\n})\n</code></pre>\n<br>\n<h1>6. 변수, 상수 선언</h1>\n<ul>\n<li><code>var</code> : ES6문법 이전부터 사용하던 변수 선언</li>\n<li><code>let</code> : 기존 var를 대체하는 변수로, 선언되더라도 <strong>변경이 가능</strong>하다.</li>\n<li><code>const</code> : <strong>변하지않는 값(상수)</strong>를 선언,</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>var</th>\n<th>let</th>\n<th>const</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>scope</td>\n<td>function</td>\n<td>block</td>\n<td>block</td>\n</tr>\n<tr>\n<td>재선언</td>\n<td>O</td>\n<td>X</td>\n<td>X</td>\n</tr>\n<tr>\n<td>재할당</td>\n<td>O</td>\n<td>O</td>\n<td>X</td>\n</tr>\n<tr>\n<td>호이스팅</td>\n<td>O</td>\n<td>X</td>\n<td>X</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>함수 레벨 스코프(Function level scope) * 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.</li>\n<li>블록 레벨 스코프(Block level scope) * 중괄호{} 내부 블록에서만 유효한 변수로, 코드 블록 내부에서 선언한 변수는 지역 변수이다.</li>\n</ul>\n<br>\n<h4>1. let</h4>\n<pre><code class=\"language-javascript\">//기존\nvar num = 1 // 전역 변수\nconsole.log(num) // 1\n\n{\n    var num = 1 // 전역 변수\n}\nconsole.log(num) // 2\n\n//ES6\nlet one = 1 // 전역 변수\n{\n    let one = 2 // 지역 변수\n    let three = 3 // 지역 변수\n}\nconsole.log(one) // 1\nconsole.log(three) // ReferenceError: three is not defined\n</code></pre>\n<ul>\n<li>let은 블록 레벨 스코프이기 때문에 <code>one</code>는 먼저 선언된 1이란 값이 나오고 <code>three</code>은 블록 밖에서는 정의되지 않은 변수라고 나온다.</li>\n</ul>\n<pre><code class=\"language-javascript\">//기존\nvar num = 1\nvar num = 2 // 중복 선언 가능\n\n//ES6\nlet num = 1\nlet num = 2 // Identifier 'num' has already been declared\n</code></pre>\n<ul>\n<li>같은 레벨에서 <code>var</code>은 재설정이 가능하지만, <code>let</code>은 재설정 불가능</li>\n</ul>\n<pre><code class=\"language-javascript\">//기존\nconsole.log(num) //undefined\nvar num = 1\n\n//ES6\nconsole.log(num) //Cannot access 'num' before initialization\nlet num = 1\n</code></pre>\n<ul>\n<li>호이스팅(hoisting) : 변수의 선언문을 유효 범위의 최상단으로 끌어올리는 행위</li>\n</ul>\n<br>\n<h4>2. const</h4>\n<pre><code class=\"language-javascript\">//기존\nvar num = 1\nnum = 2\n\n//ES6\nconst num = 1\nnum = 2 // Identifier 'num' has already been declared\n</code></pre>\n<ul>\n<li>var, let은 재할당이 자유로우나 const는 재항당이 불가하다.</li>\n<li><strong>const 반드시 선언과 동시에 할당이 이루어져야한다.</strong></li>\n</ul>\n<pre><code class=\"language-javascript\">const num = {\n    one: 1,\n    two: 2,\n}\n\nnum.one = 2\nconsole.log(num) //{one: 2, two: 2}\n</code></pre>\n<ul>\n<li>const는 재할당이 되지 않지만, 객체를 선언하는 경우 객체의 프로퍼티는 보호되지 않는다.<br>\n즉, <strong>객체의 내용이 변경 가능하다.</strong></li>\n</ul>\n<br>\n<p>------------------------ class 부터</p>\n<p><br><br><br><br><br></p>\n<blockquote>\n<p><subtitle> refernece</p>\n</blockquote>\n<ul>\n<li><a href=\"https://webapplog.com/es6/\">https://webapplog.com/es6/</a></li>\n<li><a href=\"https://yunyoung1819.tistory.com/123\">https://yunyoung1819.tistory.com/123</a></li>\n<li><a href=\"https://poiemaweb.com/\">https://poiemaweb.com/</a></li>\n</ul>","frontmatter":{"title":"자바스크립트 - ES6 문법 정리"},"excerpt":"ECMAScript란?  자바스크립트 표준 문법으로, 넷스케이프라는 회사에서 자바스크립트를 표준화하기 위해 만들어 낸 기술 규격이다.  1. 기본 매개 변수 매개변수에 기본값을 지정해줄 수 있다.…"}},"pageContext":{"slug":"/posts/Blog/2019-12-11-es6-1/"}}}