{"componentChunkName":"component---src-templates-post-view-js","path":"/posts/2019-12-17-this/","result":{"data":{"markdownRemark":{"html":"<h1>1. this는?</h1>\n<p>함수를 호출 할때, 함수가 어떻게 호출되었는지에 따라 값이 바뀐다.</p>\n<p>함수를 호출하는 방식에는 아래 예시가 있다.</p>\n<ol>\n<li>전역 호출</li>\n<li>함수 호출</li>\n<li>메소드 호출</li>\n<li>생성자 함수 호출</li>\n<li>apply/call/bind 호출</li>\n</ol>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">var fruit = function () {\n    console.log(this)\n}\n\n// 1. 전역 호출 &amp; 함수 호출\nconsole.log(this) // window\nfruit() // window\n\n// 3. 메소드 호출\nvar obj = { fruit: apple }\nobj.fruit() // apple\n\n// 4. 생성자 함수 호출\nvar apple = new fruit() // fruit\n\n// 5. apply/call/bind 호출\nvar apple = { name: &quot;apple&quot; }\nfruit.call(apple) // apple\nfruit.apply(apple) // apple\nfruit.bind(apple)() // apple</code>\n        </deckgo-highlight-code>\n<br>\n<h2>1. 전역 호출 &#x26; 함수 호출</h2>\n<p>전역객체는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser에서 <strong>window</strong>, Node.js에서 <strong>global</strong> 을 의미한다.</p>\n<p>기본적으로 <code>this</code>는 전역객체에 바인딩된다.</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">var fruit = &quot;apple&quot;\nconsole.log(fruit) // apple\nconsole.log(window.fruit) // apple\n\nfunction fruitName() {\n    console.log(this.fruit)\n}\n\nfruitName() // apple</code>\n        </deckgo-highlight-code>\n<br>\n<h2>2. 메소드 호출</h2>\n<p>객체의 프로퍼티가 함수일 경우를 메소드라고 부르는데<br>\n이러한 메소드를 호출할 때 내부 <code>this</code>는 해당 메소드를 호출한 객체에 바인딩된다.</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">var fruit1 = {\n    name: &quot;apple&quot;,\n    fruitName: function () {\n        console.log(this.name)\n    },\n}\n\nvar fruit2 = {\n    name: &quot;banana&quot;,\n}\n\nfruit2.fruitName = fruit1.fruitName\nfruit1.fruitName() // apple\nfruit2.fruitName() // banana</code>\n        </deckgo-highlight-code>\n<br>\n<h2>3. 생성자 함수 호츌</h2>\n<p>기존 함수에 new 연산자를 붙여서 호출하는 함수로,\nnew 연산자로 호출한 객체에 바인딩된다.</p>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">function fruitName(name) {\n    this.name = name\n}\n\nvar fruit1 = new fruitName(&quot;apple&quot;)\nconsole.log(fruit1.name) // apple\n\nvar fruit2 = new fruitName(&quot;banana&quot;)\nconsole.log(fruit2.name) // banana</code>\n        </deckgo-highlight-code>\n<br>\n<h2>3. apply/call/bind 호출</h2>\n<p><code>apply</code>, <code>call</code>는 자바스크립트 엔진의 암묵적인 this 바인딩이 아닌 임의로 바인딩하는 Function.prototype 객체의 메소드이다.</p>\n<h2><code>apply</code></h2>\n<h4>문법</h4>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">function.apply(thisArg, argArray)</code>\n        </deckgo-highlight-code>\n<ul>\n<li>thisArg : this에 바인딩할 객체</li>\n<li>argArray : 함수를 호출할 때 넘길 인자들의 배열</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">var fruit = function(name){\n\tthis.name = name;\n}\n\nvar apple = {};\n\nfruit.apply(apple, {&#39;apple&#39;});\nconsole.log(apple) // { name: &#39;apple&#39; }</code>\n        </deckgo-highlight-code>\n<br>\n<h2><code>call</code></h2>\n<h4>문법</h4>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">function.call(thisArg[, arg1[, arg2[, ...]]])</code>\n        </deckgo-highlight-code>\n<ul>\n<li>thisArg : this에 바인딩할 객체</li>\n<li>arg : 객체를 위한 인수</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">var fruit = function (name) {\n    this.name = name\n}\n\nvar apple = {}\n\nfruit.call(apple, &quot;apple&quot;)\nconsole.log(apple) // { name: &#39;apple&#39; }</code>\n        </deckgo-highlight-code>\n<br>\n<h2><code>bind</code></h2>\n<p><code>bind</code>는 <code>apply</code>, <code>call</code> 메소드와는 다르게 함수를 실행시키지 않기때문에 명시적으로 함수를 호출할 필요가 있다.</p>\n<h4>문법</h4>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">function.call(thisArg[, arg1[, arg2[, ...]]])</code>\n        </deckgo-highlight-code>\n<ul>\n<li>thisArg : this에 바인딩할 객체</li>\n<li>arg : 객체를 위한 인수</li>\n</ul>\n<deckgo-highlight-code language=\"javascript\"  terminal=\"carbon\" theme=\"one-dark\" >\n          <code slot=\"code\">var fruit = function (name) {\n    this.name = name\n}\n\nvar apple = {}\n\nfruit.bind(apple)(&quot;apple&quot;)\nconsole.log(apple) // { name: &#39;apple&#39; }</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p><subtitle> refernece</p>\n</blockquote>\n<ul>\n<li><a href=\"https://poiemaweb.com/\">https://poiemaweb.com/</a></li>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this\">https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this</a></li>\n</ul>","frontmatter":{"title":"자바스크립트 - this 이해하기","date":"2019-12-17","image":null},"id":"4ad54398-de20-59ac-8883-6aa069d937e2"}},"pageContext":{"slug":"/posts/2019-12-17-this/"}},"staticQueryHashes":["1707471100","3159585216","35752167"]}